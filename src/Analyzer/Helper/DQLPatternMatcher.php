<?php

/*
 * This file is part of the Doctrine Doctor.
 * (c) 2025-2026 Ahmed EBEN HASSINE
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace AhmedBhs\DoctrineDoctor\Analyzer\Helper;

/**
 * Pattern matcher for Doctrine Query Language (DQL).
 *
 * This class encapsulates DQL pattern matching logic with well-documented methods.
 * Each pattern has its own method for better maintainability and testability.
 *
 * Why regex here? There is NO external DQL parser library available. The only way
 * to parse DQL is using Doctrine's internal parser ($em->createQuery()->getAST()),
 * which is heavy and throws exceptions. These lightweight regex patterns provide
 * fast pre-filtering before full parsing.
 */
class DQLPatternMatcher
{
    /**
     * Detects if SQL was generated by Doctrine (vs hand-written SQL).
     *
     * Doctrine generates aliases following pattern: t0_, t1_, t2_, etc.
     * Example: SELECT t0_.id, t0_.name FROM users t0_
     *
     * This helps distinguish DQL-generated SQL from native SQL queries.
     */
    public function hasDoctrineSQLPattern(string $sql): bool
    {
        // Look for Doctrine's table alias pattern with space before
        return 1 === preg_match('/\st\d+_/', $sql);
    }

    /**
     * Checks if query looks like pure DQL (vs compiled SQL).
     *
     * DQL uses entity class names, not table names:
     * - FROM App\Entity\User (namespaced class)
     * - SELECT u.name FROM User u (entity with alias)
     *
     * This distinguishes DQL from SQL for different validation rules.
     */
    public function looksPureDQL(string $query): bool
    {
        return $this->hasNamespacedEntity($query)
            || $this->hasEntityWithAlias($query);
    }

    /**
     * Detects namespaced entity class in FROM clause.
     *
     * Pattern: FROM App\Entity\User or FROM MyBundle\Entity\Product
     *
     * Example: SELECT u FROM App\Entity\User u
     */
    public function hasNamespacedEntity(string $query): bool
    {
        // Match FROM followed by class name with backslashes (namespace)
        return 1 === preg_match('/FROM\s+[A-Z]\w*\\\\[A-Z]\w*/i', $query);
    }

    /**
     * Detects DQL with entity alias pattern.
     *
     * Pattern: SELECT alias.field FROM Entity alias
     *
     * Example: SELECT u.name FROM User u WHERE u.active = true
     */
    public function hasEntityWithAlias(string $query): bool
    {
        // Match: SELECT alias.field FROM EntityName alias
        return 1 === preg_match('/SELECT\s+\w+\.\w+\s+FROM\s+[A-Z]\w+\s+\w+/', $query);
    }

    /**
     * Extracts entity class names from FROM clause.
     *
     * Returns array of entity class names (potentially fully qualified).
     *
     * Example: "FROM App\Entity\User" → ['App\Entity\User']
     * Example: "FROM User" → ['User']
     *
     * @return string[]
     */
    public function extractEntityClassesFromFrom(string $query): array
    {
        if (preg_match_all('/FROM\s+([\w\\\\]+)/i', $query, $matches) < 1) {
            return [];
        }

        $entities = [];
        foreach ($matches[1] as $entityClass) {
            // Skip if it's a table name (lowercase start, or has underscores)
            if (ctype_lower($entityClass[0]) || str_contains($entityClass, '_')) {
                continue;
            }

            $entities[] = $entityClass;
        }

        return $entities;
    }

    /**
     * Extracts entity class names from JOIN clauses.
     *
     * Returns array of entity class names from JOIN statements.
     *
     * Example: "JOIN App\Entity\Order" → ['App\Entity\Order']
     *
     * @return string[]
     */
    public function extractEntityClassesFromJoin(string $query): array
    {
        if (preg_match_all('/JOIN\s+([\w\\\\]+)/i', $query, $matches) < 1) {
            return [];
        }

        $entities = [];
        foreach ($matches[1] as $entityClass) {
            // Skip if it's a table name (lowercase start, or has underscores)
            if (ctype_lower($entityClass[0]) || str_contains($entityClass, '_')) {
                continue;
            }

            $entities[] = $entityClass;
        }

        return $entities;
    }

    /**
     * Extracts table name and alias from FROM clause.
     *
     * Returns array with table name and alias, or null if not found.
     *
     * Example: "FROM users u" → ['table' => 'users', 'alias' => 'u']
     * Example: "FROM App\Entity\User u" → ['table' => 'App\Entity\User', 'alias' => 'u']
     *
     * @return array{table: string, alias: string}|null
     */
    public function extractTableAndAlias(string $query): ?array
    {
        if (1 !== preg_match('/FROM\s+(\w+)\s+(\w+)/i', $query, $matches)) {
            return null;
        }

        return [
            'table' => $matches[1],
            'alias' => $matches[2],
        ];
    }

    /**
     * Extracts field references for a specific alias.
     *
     * Example with alias 'u': "u.name, u.email" → ['name', 'email']
     *
     * @return string[]
     */
    public function extractFieldReferences(string $query, string $alias): array
    {
        $pattern = sprintf('/%s\.(\w+)/i', preg_quote($alias, '/'));

        if (preg_match_all($pattern, $query, $matches) < 1) {
            return [];
        }

        $fields = [];
        foreach ($matches[1] as $fieldName) {
            // Skip SQL keywords
            if (in_array(strtoupper($fieldName), ['AS', 'FROM', 'WHERE', 'AND', 'OR'], true)) {
                continue;
            }

            $fields[] = $fieldName;
        }

        return array_values(array_unique($fields));
    }

    /**
     * Formats DQL/SQL for display with proper indentation.
     *
     * Makes queries more readable by breaking on SQL keywords.
     *
     * Example:
     * "SELECT u FROM User u WHERE u.active = 1" →
     * "SELECT u
     *   FROM User u
     *   WHERE u.active = 1"
     */
    public function formatQueryForDisplay(string $query, int $maxLength = 500): string
    {
        // Normalize whitespace
        $formatted = preg_replace('/\s+/', ' ', $query) ?? $query;

        // Add line breaks before major keywords
        $formatted = str_replace(
            [' FROM ', ' WHERE ', ' JOIN ', ' ORDER BY ', ' GROUP BY ', ' LIMIT '],
            ["\n  FROM ", "\n  WHERE ", "\n  JOIN ", "\n  ORDER BY ", "\n  GROUP BY ", "\n  LIMIT "],
            $formatted,
        );

        // Truncate if too long
        if (strlen($formatted) > $maxLength) {
            return substr($formatted, 0, $maxLength) . "\n  ... (truncated)";
        }

        return $formatted;
    }

    /**
     * Normalizes whitespace in a query string.
     *
     * Replaces multiple spaces, tabs, newlines with single space.
     * Useful for comparison and caching.
     */
    public function normalizeWhitespace(string $query): string
    {
        return preg_replace('/\s+/', ' ', trim($query)) ?? trim($query);
    }

    /**
     * Extracts JOIN associations from query.
     *
     * Pattern: JOIN alias.association newAlias
     *
     * Example: "LEFT JOIN u.orders o" → [['source' => 'u', 'association' => 'orders', 'alias' => 'o']]
     *
     * Note: This is a simplified extraction. Full validation would require
     * tracking which entity each alias represents (complex state tracking).
     *
     * @return array<array{source: string, association: string, alias: string}>
     */
    public function extractJoinAssociations(string $query): array
    {
        // Pattern: LEFT JOIN / INNER JOIN / JOIN followed by alias.association newAlias
        // Example: JOIN u.orders o
        if (preg_match_all('/(?:LEFT\s+|INNER\s+)?JOIN\s+(\w+)\.(\w+)\s+(\w+)/i', $query, $matches) < 1) {
            return [];
        }

        $joins = [];
        $count = count($matches[0]);

        for ($i = 0; $i < $count; ++$i) {
            $joins[] = [
                'source' => $matches[1][$i],       // Source alias (e.g., 'u')
                'association' => $matches[2][$i],  // Association name (e.g., 'orders')
                'alias' => $matches[3][$i],        // New alias (e.g., 'o')
            ];
        }

        return $joins;
    }

    /**
     * Builds a simple alias-to-entity map from the query.
     *
     * This is a best-effort approach to track which alias represents which entity.
     * Only works for simple cases: FROM EntityName alias
     *
     * Example: "FROM User u" → ['u' => 'User']
     *
     * @return array<string, string> Map of alias => entity class
     */
    public function buildAliasMap(string $query): array
    {
        $map = [];

        // Extract FROM clause: FROM EntityName alias
        if (preg_match_all('/FROM\s+([\w\\\\]+)\s+(\w+)/i', $query, $matches) >= 1) {
            $count = count($matches[0]);
            for ($i = 0; $i < $count; ++$i) {
                $entityClass = $matches[1][$i];
                $alias = $matches[2][$i];

                // Only track entities (not table names)
                if (!ctype_lower($entityClass[0]) && !str_contains($entityClass, '_')) {
                    $map[$alias] = $entityClass;
                }
            }
        }

        return $map;
    }
}
